# -*- coding: utf-8 -*-
"""hfthomework2AlyonaNefyodova

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bGlFoCN55LgOAxoTrmRreUY71xoP88gP
"""

from dataclasses import dataclass
from typing import Optional
from typing import Deque
from collections import deque
import numpy as np
import pandas as pd

@dataclass
class Order:  # Our own placed order
    order_id: int
    side: str
    size: float
    price: float
    timestamp: int

@dataclass
class AnonTrade:  
    timestamp: float
    side: str
    size: float
    price: str

@dataclass
class OwnTrade:  # Execution of own placed order
    timestamp: int
    trade_id: int
    order_id: int
    side: str
    size: float
    price: float

@dataclass
class OrderbookSnapshotUpdate:  # Orderbook tick snapshot
    timestamp: int
    asks:  [] 
    bids: []

@dataclass
class MdUpdate:  # Data of a tick
    orderbook: Optional[OrderbookSnapshotUpdate] = None
    trades: Optional[AnonTrade] = None
    timestamp: int = 0

#preparing data
def load_md_from_file() -> [MdUpdate]:
   lobs = pd.read_csv('lobs.csv', delimiter=',', skipinitialspace = True)
   for name in lobs:
     if 'btcusdt:Binance:LinearPerpetual' in name:
       lobs.rename(columns={name: "_".join(name.split("_")[1:])}, inplace=True)
   trades = pd.read_csv('trades.csv', delimiter=',')
   lobs['is_lobs'] = 1
   #тут срез, а не все дата, тк и коллаб и мой компьютер отвалились, когда я всю взяла...
   trades_lobs = pd.concat([lobs[:1000], trades[:1000]], ignore_index=True)
   sorted_trades_lobs = trades_lobs.sort_values(by='receive_ts')
   sorted_trades_lobs = sorted_trades_lobs.reset_index()
   current_md = MdUpdate()
   current_md.timestamp = sorted_trades_lobs['receive_ts'][0]
   current_ts = 0
   result_data = []

   for index, row in sorted_trades_lobs.iterrows():
    #если время поменялось c предыдущей итерации, добавляем маркет дату предыдущего времени в итоговый список и обнуляем предыдущую маркет дату. 
    if current_ts != row['exchange_ts']:
      if index !=0:
        result_data.append(current_md)
      current_md = MdUpdate()
      current_md.timestamp = row['receive_ts']

    #если это lobs, записываем все цены-объемы
    if not np.isnan(row['is_lobs']):
      current_md.orderbook = OrderbookSnapshotUpdate(row['receive_ts'], [], [])
      for i in range(10):
        current_md.orderbook.asks.append((row['ask_price_' + str(i)], row['ask_vol_' + str(i)]))
        current_md.orderbook.bids.append((row['bid_price_' + str(i)], row['bid_vol_' + str(i)]))
      current_ts = current_md

    #если это trades, записываем всю информацию
    if np.isnan(row['is_lobs']):
      if current_md.trades is None:
        current_md.trades = []
      current_md.trades.append(AnonTrade(row['receive_ts'], row['aggro_side'], row['size'], row['price']))
      current_ts = current_md
      
    return result_data

class Sim:
    def __init__(self, execution_latency: float, md_latency: float) -> None:
      self.order_id: int = 0
      self.pending_orders = deque()
      self.pending_orders_to_canсel = deque()
      self.md_latency = md_latency
      self.current_md: Optional[MdUpdate] = None
      self.current_ts: int = 0
      self.execution_latency = execution_latency
      self.active_orders = deque()
      self.executed_orders = deque()
      self.executed_own_trades = deque()
      self.md = iter(load_md_from_file())

    def prepare_orders(self):
      while (len(self.pending_orders) > 0) and (self.pending_orders[0].timestamp + self.md_latency < self.current_ts):
        self.active_orders.append(self.pending_orders.popleft())

    def place_order(self, side: str, size: int, price: int):
      neworder = Order(self.current_ts, self.order_id, side, size, price)
      self.order_id += 1
      self.pending_orders.append(neworder)
      return (neworder)

    def execute_orders(self):
      p_trade_min_buy: float = np.inf
      p_trade_max_sell: float = 0
      executed_trades_indices: list = []
      trades = self.current_md.trades
      #лучшие цены трейдов за тик
      for trade in trades:
        p_trade_max_sell = max(p_trade_max_sell, trade.price)
        p_trade_min_buy= min(p_trade_min_buy, trade.price)
      #следующий иф на случай если вдруг в какой-то тик мы получили и информацию о трейдах и снепшот стакана, но трейд произошел по цене хуже, чем была в стакане
      if self.current_md.orderbook:
        p_trade_min_buy = min(p_trade_min_buy, self.currrent_md.orderbook.bids[0][0])
        p_trade_max_sell = max(p_trade_max_sell, self.current_md.orderbook.asks[0][0])

      for active_order in self.active_orders:
        if active_order.side == 'bid' and active_order.price > p_trade_max_sell:
          self.executed_orders.append(active_order)
          executed_trades_indices.append(active_order.order_id)
        if active_order.side == 'ask' and active_order.price < p_trade_min_buy:
          self.executed_orders.append(active_order)
          executed_trades_indices.append(active_order.order_id)
          
      #удаляем исполненные ордера и записываем их в исполненные трейды
      for active_order in self.active_orders:
        if active_order.order_id in executed_trades_indices:
          executed_own_trade = OwnTrade(active_order.timestamp,1, active_order.order_id, active_order.side, active_order.size, active_order.price)
          executed_own_trades.append(executed_own_trade)
          executed_own_trades[-1].trade_id = (len(executed_own_trades)-1)
          self.active_orders.remove(active_order)
                
      return()

    def cancel_order(self, id: int):
      self.pending_orders_to_canсel.append(id)

    def tick(self) -> MdUpdate:
        self.current_md = next(self.md)
        self.current_ts = self.current_md.timestamp
        self.execute_orders()
        self.prepare_orders()
        return next(self.md)

class Strategy:
    def __init__(self, max_position: float) -> None:
        pass        
    def run(self, sim: "Sim"):
        while True:
            try:
                md_update = sim.tick()
                # здесь не хватает генерирования новых ордеров
            except StopIteration:
                break

if __name__ == "__main__":
    strategy = Strategy(10)
    sim = Sim(10*1000000, 10*1000000)
    strategy.run(sim)